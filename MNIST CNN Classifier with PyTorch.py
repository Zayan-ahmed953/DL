# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z5Xe9oFCCU9Yf00gFIGvY69M62TFOrq0
"""

import torch
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt
import numpy as np
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torch

print("GPU available: {}".format(torch.cuda.is_available()))

if torch.cuda.is_available():
    device = torch.device("cuda")
else:
    device = torch.device("cpu")

transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,),(0.5,))])

trainset = torchvision.datasets.MNIST('mnist',
                                  train = True,
                                  download = True,
                                  transform = transform)

testset = torchvision.datasets.MNIST('mnist',
                                     train = False,
                                     download = True,
                                     transform = transform)

trainset.data.shape

testset.data.shape

torch.Size([60000, 28, 28])
torch.Size([10000, 28, 28])

print(trainset.data[0].shape)
print(trainset.data[0])

import cv2
import numpy as np
import matplotlib.pyplot as plt

def imgshow(title = "", image = None, size = 6):
  w,h = image.shape[0], image.shape[1]
  aspect_ratio = w/h
  plt.figure(figsize = (size*aspect_ratio, size))
  plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
  plt.title(title)
  plt.show()

image = trainset.data[0].numpy()
imgshow("MNIST Sameple", image)

figure = plt.figure()
num_of_imgs = 50

for index in range(1, num_of_imgs + 1):
  plt.subplot(5, 10, index)
  plt.axis('off')
  plt.imshow(trainset.data[index], cmap = 'gray_r')

trainloader = torch.utils.data.DataLoader(trainset, batch_size = 128, shuffle = True, num_workers = 0)
testloader = torch.utils.data.DataLoader(testset, batch_size = 128, shuffle = False, num_workers = 0)

type(trainloader)

dataiter = iter(trainloader)
images, labels = next(dataiter) # Use next(dataiter) instead of dataiter.next()
print(images.shape)
print(labels.shape)

images[0].shape

import matplotlib.pyplot as plt
import numpy as np

def imgshow(img):
  img = img / 2 + 0.5
  npimg = img.numpy()
  plt.imshow(np.transpose(npimg, (1,2,0)))
  plt.show()

dataiterator = iter(trainloader)
images, labels = next(dataiterator)
imgshow(torchvision.utils.make_grid(images))

import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
  def __init__(self):
    super(Model, self).__init__()

    self.conv1 = nn.Conv2d(1, 32, 3)
    self.conv2 = nn.Conv2d(32, 64, 3) # Changed '==' to '='
    self.pool = nn.MaxPool2d(2, 2)
    self.fc1 = nn.Linear(64 * 12 * 12, 128)
    self.fc2 = nn.Linear(128, 10)

  def forward(self, x):
    x = F.relu(self.conv1(x))
    x = self.pool(F.relu(self.conv2(x)))
    x = x.view(-1, 64 * 12 * 12)
    x = F.relu(self.fc1(x))
    x = self.fc2(x)
    return x

model = Model()
model.to(device)

import torch.optim as optim

criterion = nn.CrossEntropyLoss()

optimizer = optim.SGD(model.parameters(), lr = 0.001, momentum=0.9)

epochs = 10

epoch_log = []
loss_log = []
accuracy_log = []

for epoch in range(epochs):
  print(f"Starting EPoch: {epoch + 1}...")

  running_loss = 0.0

  for i, data in enumerate(trainloader, 0):
    inputs, labels = data

    inputs = inputs.to(device)
    labels = labels.to(device)

    optimizer.zero_grad()

    outputs = model(inputs)
    loss = criterion(outputs, labels)
    loss.backward()
    optimizer.step()

    running_loss += loss.item()

    if i % 50 == 49:
      correct = 0
      total = 0
      with torch.no_grad():
        for data in testloader:
          images, labels = data

          images = images.to(device)
          labels = labels.to(device)

          outputs = model(images)

          _, predicted = torch.max(outputs.data, dim = 1)

          total += labels.size(0)
          correct += (predicted == labels).sum().item()

      accuracy = 100 * correct / total
      epoch_num = epoch + 1
      actual_loss = running_loss / 50

      print(f"Epoch: {epoch_num}, Mini- batches completed {(i + 1)}, Loss: {actual_loss}, Test Accuracy = {accuracy: 0.3f}%")

      running_loss = 0.0

      epoch_log.append(epoch_num)
      loss_log.append(actual_loss)
      accuracy_log.append(accuracy)

  print("Finished Training")

Path = "model.pth"
torch.save(model.state_dict(), Path)

dataiter = iter(testloader)
images, label = next(dataiter)

imgshow(torchvision.utils.make_grid(images))

model = Model()
model.to(device)

model.load_state_dict(torch.load(Path))

test_iter = iter(testloader)
images, labels = next(test_iter)

images = images.to(device)
labels = labels.to(device)

outputs = model(images)
_, predicted = torch.max(outputs, 1)

print('Predicted: ', ''.join('%1s' % predicted[j].cpu().numpy() for j in range(128)))

correct = 0
total = 0

with torch.no_grad():
  for data in testloader:
    images, labels = data

    images = images.to(device)
    labels = labels.to(device)

    outputs = model(images)

    _, predicted = torch.max(outputs.data, 1)

    total += labels.size(0)
    correct += (predicted == labels).sum().item()

accuracy = 100 * correct / total
print(f"Test Accuracy = {accuracy: 0.3f}%")

epoch_log

loss_log

accuracy_log

fig, ax1 = plt.subplots()

plt.title("Accuracy vs Loss")
plt.xticks(rotation = 45)

ax2 = ax1.twinx()

ax1.plot(epoch_log, loss_log, 'g-')
ax2.plot(epoch_log, accuracy_log, 'b-')

ax1.set_xlabel("Epochs")
ax1.set_ylabel("Loss", color = 'g')

ax2.set_ylabel("Accuracy", color = 'b')

plt.show

